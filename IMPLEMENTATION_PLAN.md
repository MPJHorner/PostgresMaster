# Implementation Plan: Browser-Only Postgres Client MVP

## Architecture Summary

**Stack:**
- **Frontend**: SvelteKit (static) + shadcn-svelte + Monaco Editor + TailwindCSS
- **Backend Proxy**: Go binary (WebSocket server ↔ Postgres client)
- **Communication**: WebSocket with JSON messages
- **Auth**: Secret-based (generated by proxy, passed via URL param)

**User Flow:**
1. User downloads Go proxy binary
2. User runs: `./postgres-proxy "postgres://..."`
3. Proxy connects to Postgres, outputs: `http://localhost:8080?secret=xyz`
4. User opens URL in browser
5. Web app connects via WebSocket using secret
6. User writes and executes SQL queries

---

## Phase 1: Project Setup & Go Proxy (3 days)

### 1.1 Initialize Monorepo Structure
```bash
postgres-client/
├── web/          # SvelteKit app
├── proxy/        # Go binary
├── docs/         # Documentation
└── README.md
```

**Tasks:**
- [ ] Create directory structure
- [ ] Initialize Git repository
- [ ] Add `.gitignore` for both Go and Node.js
- [ ] Create top-level `README.md` with project overview

---

### 1.2 Go Proxy - Core Setup

**Directory structure:**
```
proxy/
├── cmd/
│   └── proxy/
│       └── main.go           # Entry point
├── pkg/
│   ├── server/
│   │   └── websocket.go      # WebSocket server
│   ├── postgres/
│   │   └── client.go         # Postgres client
│   ├── protocol/
│   │   └── messages.go       # Message types
│   └── auth/
│       └── secret.go         # Secret generation & validation
├── go.mod
├── go.sum
├── Makefile                  # Cross-compile targets
└── README.md
```

**Tasks:**
- [ ] Initialize Go module: `go mod init github.com/youruser/postgres-client/proxy`
- [ ] Add dependencies:
  ```bash
  go get github.com/gorilla/websocket
  go get github.com/jackc/pgx/v5
  go get github.com/spf13/cobra  # optional, for nice CLI
  ```

---

### 1.3 Go Proxy - Connection String Parser & Interactive Mode

**File: `cmd/proxy/main.go`**

Features:
- Parse Postgres connection string from CLI arg
- Fallback to interactive mode if no args
- Retry logic with exponential backoff
- Generate secure random secret (32 characters)
- Test Postgres connection before starting WebSocket server

**Pseudo-code:**
```go
func main() {
    var connStr string

    // Option A: Parse from CLI args
    if len(os.Args) > 1 {
        connStr = os.Args[1]
    } else {
        // Option B: Interactive mode
        connStr = promptForConnection()
    }

    // Connect to Postgres with retries
    db, err := connectWithRetry(connStr, maxRetries=3)
    if err != nil {
        log.Fatal("Failed to connect to Postgres:", err)
    }

    // Generate secret
    secret := generateSecret()  // crypto/rand, 32 chars

    // Start WebSocket server
    server := NewWebSocketServer(db, secret)
    server.Start(":8080")

    // Output URL for user
    fmt.Printf("\n✓ Connected to Postgres!\n")
    fmt.Printf("→ Open in browser: http://localhost:8080?secret=%s\n\n", secret)

    // Block until interrupt
    <-signalChan
}
```

**Tasks:**
- [ ] Implement connection string parsing
- [ ] Implement interactive prompt (use `bufio.Scanner`)
- [ ] Implement `connectWithRetry` with exponential backoff
- [ ] Implement `generateSecret` using `crypto/rand`
- [ ] Add graceful shutdown on SIGINT/SIGTERM

---

### 1.4 Go Proxy - WebSocket Server

**File: `pkg/server/websocket.go`**

Features:
- CORS-enabled WebSocket server
- Validate secret on connection
- Handle JSON messages
- Route to Postgres client
- Stream results back to browser

**Message Types (from PRD):**
```go
// Client → Server
type ClientMessage struct {
    Type    string          `json:"type"`    // "query" | "introspect"
    Payload json.RawMessage `json:"payload"`
}

type QueryPayload struct {
    SQL     string `json:"sql"`
    Timeout int    `json:"timeout"` // milliseconds, optional
}

// Server → Client
type ServerMessage struct {
    Type    string          `json:"type"`    // "result" | "error" | "schema"
    Payload json.RawMessage `json:"payload"`
}

type ResultPayload struct {
    Rows          []map[string]interface{} `json:"rows"`
    Columns       []ColumnInfo             `json:"columns"`
    RowCount      int                      `json:"rowCount"`
    ExecutionTime int                      `json:"executionTime"` // ms
}

type ErrorPayload struct {
    Error string `json:"error"`
}

type SchemaPayload struct {
    Tables []TableInfo `json:"tables"`
}
```

**Tasks:**
- [ ] Implement WebSocket upgrade handler
- [ ] Validate secret from URL query param
- [ ] Implement message router (switch on `type`)
- [ ] Add CORS headers for localhost
- [ ] Handle connection errors gracefully

---

### 1.5 Go Proxy - Postgres Client

**File: `pkg/postgres/client.go`**

Features:
- Execute SQL queries
- Return results as JSON-serializable format
- Schema introspection (query `pg_catalog` and `information_schema`)
- Handle Postgres errors gracefully
- Query timeout support

**Key Functions:**
```go
func (c *Client) ExecuteQuery(ctx context.Context, sql string) (*QueryResult, error)
func (c *Client) IntrospectSchema(ctx context.Context) (*SchemaInfo, error)
```

**Schema Introspection Query:**
```sql
-- Get all tables
SELECT
    table_schema,
    table_name,
    table_type
FROM information_schema.tables
WHERE table_schema NOT IN ('pg_catalog', 'information_schema')
ORDER BY table_schema, table_name;

-- Get columns for a table
SELECT
    column_name,
    data_type,
    is_nullable,
    column_default
FROM information_schema.columns
WHERE table_schema = $1 AND table_name = $2
ORDER BY ordinal_position;
```

**Tasks:**
- [ ] Implement `ExecuteQuery` with `pgx`
- [ ] Convert `pgx.Rows` to JSON-friendly format
- [ ] Implement `IntrospectSchema`
- [ ] Add query timeout context handling
- [ ] Handle common Postgres errors (syntax, permissions, etc.)

---

### 1.6 Go Proxy - Build System

**File: `Makefile`**

Build targets for all platforms:
```makefile
BINARY_NAME=postgres-proxy
VERSION=0.1.0

.PHONY: all build-all clean

all: build-all

build-all: \
	build-windows-amd64 \
	build-darwin-amd64 \
	build-darwin-arm64 \
	build-linux-amd64 \
	build-linux-arm64

build-windows-amd64:
	GOOS=windows GOARCH=amd64 go build -o bin/$(BINARY_NAME)-windows-amd64.exe cmd/proxy/main.go

build-darwin-amd64:
	GOOS=darwin GOARCH=amd64 go build -o bin/$(BINARY_NAME)-darwin-amd64 cmd/proxy/main.go

build-darwin-arm64:
	GOOS=darwin GOARCH=arm64 go build -o bin/$(BINARY_NAME)-darwin-arm64 cmd/proxy/main.go

build-linux-amd64:
	GOOS=linux GOARCH=amd64 go build -o bin/$(BINARY_NAME)-linux-amd64 cmd/proxy/main.go

build-linux-arm64:
	GOOS=linux GOARCH=arm64 go build -o bin/$(BINARY_NAME)-linux-arm64 cmd/proxy/main.go

clean:
	rm -rf bin/

test:
	go test ./... -v

lint:
	golangci-lint run
```

**Tasks:**
- [ ] Create Makefile with cross-compile targets
- [ ] Test build for all platforms
- [ ] Verify binary sizes (should be < 10MB)
- [ ] Add GitHub Actions workflow for releases (optional for MVP)

---

### 1.7 Go Proxy - Testing

**Files:**
- `pkg/server/websocket_test.go`
- `pkg/postgres/client_test.go`
- `pkg/auth/secret_test.go`

**Tests:**
- [ ] Secret generation (length, randomness)
- [ ] Secret validation
- [ ] Connection string parsing
- [ ] WebSocket message serialization/deserialization
- [ ] Integration test: proxy → mock Postgres

**Run:**
```bash
go test ./... -v -cover
```

**Target:** 80% code coverage

---

## Phase 2: Web App Foundation (2 days)

### 2.1 SvelteKit Setup

**Initialize project:**
```bash
cd web
npm create svelte@latest .
# Choose:
# - Skeleton project
# - TypeScript: Yes
# - ESLint: Yes
# - Prettier: Yes
# - Playwright: No (for MVP)
# - Vitest: Yes
```

**Install dependencies:**
```bash
npm install
npm install -D @sveltejs/adapter-static
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
```

**Configure static adapter (`svelte.config.js`):**
```js
import adapter from '@sveltejs/adapter-static';

export default {
  kit: {
    adapter: adapter({
      pages: 'build',
      assets: 'build',
      fallback: 'index.html',
      precompress: false,
      strict: true
    })
  }
};
```

**Tasks:**
- [ ] Initialize SvelteKit project
- [ ] Configure static adapter
- [ ] Setup TailwindCSS
- [ ] Configure Prettier & ESLint
- [ ] Test dev server: `npm run dev`
- [ ] Test build: `npm run build`

---

### 2.2 shadcn-svelte Integration

**Install shadcn-svelte:**
```bash
npx shadcn-svelte@latest init
```

Follow prompts to configure TailwindCSS and components path.

**Add components needed for MVP:**
```bash
npx shadcn-svelte@latest add button
npx shadcn-svelte@latest add input
npx shadcn-svelte@latest add card
npx shadcn-svelte@latest add table
npx shadcn-svelte@latest add alert
npx shadcn-svelte@latest add badge
npx shadcn-svelte@latest add separator
```

**Tasks:**
- [ ] Initialize shadcn-svelte
- [ ] Add required components
- [ ] Verify components render correctly
- [ ] Customize theme if needed

---

### 2.3 WebSocket Client Service

**File: `src/lib/services/websocket.ts`**

Features:
- Connect to `ws://localhost:8080?secret=xxx`
- Send/receive JSON messages
- Reconnect logic (with backoff)
- TypeScript types for messages

**Code structure:**
```typescript
export class PostgresProxyClient {
  private ws: WebSocket | null = null;
  private secret: string;

  constructor(secret: string) {
    this.secret = secret;
  }

  connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.ws = new WebSocket(`ws://localhost:8080?secret=${this.secret}`);

      this.ws.onopen = () => resolve();
      this.ws.onerror = (err) => reject(err);
      this.ws.onmessage = (event) => this.handleMessage(event);
    });
  }

  async executeQuery(sql: string): Promise<QueryResult> {
    const message: ClientMessage = {
      type: 'query',
      payload: { sql }
    };

    return this.sendAndWait(message);
  }

  async introspectSchema(): Promise<SchemaInfo> {
    const message: ClientMessage = {
      type: 'introspect',
      payload: {}
    };

    return this.sendAndWait(message);
  }

  private async sendAndWait(message: ClientMessage): Promise<any> {
    // Send message, wait for response
    // Return promise that resolves with server response
  }

  close() {
    this.ws?.close();
  }
}
```

**Tasks:**
- [ ] Implement `PostgresProxyClient` class
- [ ] Add TypeScript types for messages (match Go types)
- [ ] Implement request/response correlation (message IDs)
- [ ] Add reconnect logic with exponential backoff
- [ ] Handle WebSocket errors gracefully

---

### 2.4 Connection Flow

**File: `src/routes/+page.svelte`**

On page load:
1. Check URL for `?secret=xxx` parameter
2. If missing, show landing page with download links
3. If present, attempt to connect to proxy
4. On success, show SQL editor
5. On failure, show error message

**Code structure:**
```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import { PostgresProxyClient } from '$lib/services/websocket';

  let secret = '';
  let connected = false;
  let error = '';
  let client: PostgresProxyClient | null = null;

  onMount(async () => {
    // Parse secret from URL
    const params = new URLSearchParams(window.location.search);
    secret = params.get('secret') || '';

    if (secret) {
      await connectToProxy();
    }
  });

  async function connectToProxy() {
    try {
      client = new PostgresProxyClient(secret);
      await client.connect();
      connected = true;

      // Introspect schema
      const schema = await client.introspectSchema();
      // Store schema for autocomplete
    } catch (err) {
      error = err.message;
    }
  }
</script>

{#if !secret}
  <!-- Landing page with download links -->
{:else if !connected}
  <!-- Connecting... or error message -->
{:else}
  <!-- SQL Editor UI -->
{/if}
```

**Tasks:**
- [ ] Implement URL secret parsing
- [ ] Implement connection logic
- [ ] Show loading state while connecting
- [ ] Handle connection errors
- [ ] Store connection state in Svelte store

---

### 2.5 Landing Page (No Secret)

**File: `src/lib/components/LandingPage.svelte`**

Show when user visits without `?secret` parameter.

**Content:**
- Hero section: "Postgres Client for the Browser"
- Download section with buttons for each OS:
  - Windows (x64)
  - macOS (Intel)
  - macOS (Apple Silicon)
  - Linux (x64)
- Instructions:
  1. Download proxy for your OS
  2. Run: `./postgres-proxy "postgres://..."`
  3. Open the URL shown in your browser
- Features list
- Link to GitHub/docs

**Tasks:**
- [ ] Create landing page component
- [ ] Add download buttons (link to GitHub releases or static URLs)
- [ ] Add clear instructions
- [ ] Make it look good with shadcn components

---

## Phase 3: SQL Editor & Autocomplete (3 days)

### 3.1 Monaco Editor Integration

**Install Monaco:**
```bash
npm install monaco-editor
npm install -D vite-plugin-monaco-editor
```

**Configure Vite (`vite.config.ts`):**
```typescript
import { sveltekit } from '@sveltejs/kit/vite';
import monacoEditorPlugin from 'vite-plugin-monaco-editor';

export default {
  plugins: [
    sveltekit(),
    monacoEditorPlugin({
      languageWorkers: ['editorWorkerService'],
      customWorkers: [
        {
          label: 'sql',
          entry: 'monaco-editor/esm/vs/language/sql/sql.worker'
        }
      ]
    })
  ]
};
```

**File: `src/lib/components/Editor.svelte`**

```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import * as monaco from 'monaco-editor';

  export let value = '';
  export let onExecute: (sql: string) => void;

  let editorContainer: HTMLDivElement;
  let editor: monaco.editor.IStandaloneCodeEditor;

  onMount(() => {
    editor = monaco.editor.create(editorContainer, {
      value: value,
      language: 'sql',
      theme: 'vs-dark',
      minimap: { enabled: false },
      fontSize: 14,
      lineNumbers: 'on',
      automaticLayout: true
    });

    // Ctrl+Enter to execute
    editor.addCommand(
      monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter,
      () => onExecute(editor.getValue())
    );

    return () => editor.dispose();
  });
</script>

<div bind:this={editorContainer} class="h-96 border rounded" />
```

**Tasks:**
- [ ] Install Monaco and plugin
- [ ] Create `Editor.svelte` component
- [ ] Configure SQL language support
- [ ] Add Ctrl+Enter shortcut
- [ ] Style editor container

---

### 3.2 SQL Keyword Autocomplete

**File: `src/lib/services/autocomplete.ts`**

Register custom completion provider for Postgres-specific keywords.

**Postgres Keywords:**
```typescript
const POSTGRES_KEYWORDS = [
  'SELECT', 'FROM', 'WHERE', 'JOIN', 'INNER', 'LEFT', 'RIGHT', 'OUTER',
  'ON', 'GROUP BY', 'ORDER BY', 'HAVING', 'LIMIT', 'OFFSET',
  'INSERT', 'INTO', 'VALUES', 'UPDATE', 'SET', 'DELETE',
  'CREATE', 'TABLE', 'DROP', 'ALTER', 'INDEX', 'VIEW',
  'AS', 'DISTINCT', 'CASE', 'WHEN', 'THEN', 'ELSE', 'END',
  'AND', 'OR', 'NOT', 'IN', 'EXISTS', 'BETWEEN', 'LIKE', 'ILIKE',
  // Postgres-specific
  'RETURNING', 'CONFLICT', 'DO', 'NOTHING', 'UPSERT',
  'JSONB', 'UUID', 'ARRAY', 'HSTORE',
  // Functions
  'COUNT', 'SUM', 'AVG', 'MIN', 'MAX',
  'NOW', 'CURRENT_TIMESTAMP', 'CURRENT_DATE',
  'COALESCE', 'NULLIF', 'GREATEST', 'LEAST',
  // More...
];
```

**Register completion provider:**
```typescript
monaco.languages.registerCompletionItemProvider('sql', {
  provideCompletionItems: (model, position) => {
    const suggestions = POSTGRES_KEYWORDS.map(keyword => ({
      label: keyword,
      kind: monaco.languages.CompletionItemKind.Keyword,
      insertText: keyword,
      range: {
        startLineNumber: position.lineNumber,
        startColumn: wordStart,
        endLineNumber: position.lineNumber,
        endColumn: position.column
      }
    }));

    return { suggestions };
  }
});
```

**Tasks:**
- [ ] Create autocomplete service
- [ ] Add comprehensive Postgres keyword list
- [ ] Register completion provider
- [ ] Test autocomplete triggers

---

### 3.3 Schema-Aware Autocomplete

**File: `src/lib/stores/schema.ts`**

Store schema information in Svelte store for autocomplete.

```typescript
import { writable } from 'svelte/store';

export interface TableInfo {
  schema: string;
  name: string;
  columns: ColumnInfo[];
}

export interface ColumnInfo {
  name: string;
  dataType: string;
  nullable: boolean;
}

export const schemaStore = writable<TableInfo[]>([]);
```

**Enhance autocomplete with schema:**
```typescript
monaco.languages.registerCompletionItemProvider('sql', {
  provideCompletionItems: (model, position) => {
    const suggestions = [];

    // Add keywords
    suggestions.push(...keywordSuggestions);

    // Add table names
    schema.forEach(table => {
      suggestions.push({
        label: table.name,
        kind: monaco.languages.CompletionItemKind.Class,
        insertText: table.name,
        detail: `Table from ${table.schema}`,
        documentation: `Columns: ${table.columns.map(c => c.name).join(', ')}`
      });
    });

    // Add column names (context-aware based on cursor position)
    // TODO: Parse SQL to determine which table is in context

    return { suggestions };
  }
});
```

**Tasks:**
- [ ] Create schema store
- [ ] Fetch schema on connection
- [ ] Add table names to autocomplete
- [ ] Add column names to autocomplete
- [ ] Context-aware suggestions (detect table context)

---

### 3.4 Schema Introspection Service

**File: `src/lib/services/introspection.ts`**

```typescript
export async function introspectSchema(client: PostgresProxyClient): Promise<TableInfo[]> {
  const result = await client.introspectSchema();

  // Transform server response to TableInfo[]
  return result.tables.map(table => ({
    schema: table.schema,
    name: table.name,
    columns: table.columns
  }));
}

export async function refreshSchema(client: PostgresProxyClient) {
  const schema = await introspectSchema(client);
  schemaStore.set(schema);
}
```

**Tasks:**
- [ ] Create introspection service
- [ ] Call on initial connection
- [ ] Add manual refresh button
- [ ] Update schema store

---

## Phase 4: Query Execution & Results (2 days)

### 4.1 Query Execution Flow

**File: `src/lib/components/QueryEditor.svelte`**

Main component that contains:
- Editor
- Execute button
- Results area

```svelte
<script lang="ts">
  import Editor from './Editor.svelte';
  import Results from './Results.svelte';
  import { Button } from '$lib/components/ui/button';
  import type { PostgresProxyClient } from '$lib/services/websocket';

  export let client: PostgresProxyClient;

  let sql = '';
  let results: QueryResult | null = null;
  let error = '';
  let loading = false;

  async function executeQuery() {
    if (!sql.trim()) return;

    loading = true;
    error = '';
    results = null;

    try {
      results = await client.executeQuery(sql);
    } catch (err) {
      error = err.message;
    } finally {
      loading = false;
    }
  }
</script>

<div class="space-y-4">
  <Editor bind:value={sql} onExecute={executeQuery} />

  <div class="flex gap-2">
    <Button on:click={executeQuery} disabled={loading}>
      {loading ? 'Executing...' : 'Run Query (Ctrl+Enter)'}
    </Button>
  </div>

  {#if error}
    <Alert variant="destructive">{error}</Alert>
  {/if}

  {#if results}
    <Results data={results} />
  {/if}
</div>
```

**Tasks:**
- [ ] Create `QueryEditor` component
- [ ] Wire up execute button
- [ ] Handle loading state
- [ ] Handle errors
- [ ] Display results

---

### 4.2 Results Table Component

**File: `src/lib/components/Results.svelte`**

Display query results in a table with metadata.

```svelte
<script lang="ts">
  import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '$lib/components/ui/table';
  import { Badge } from '$lib/components/ui/badge';

  export let data: QueryResult;

  $: columns = data.columns;
  $: rows = data.rows;
</script>

<div class="space-y-4">
  <!-- Metadata -->
  <div class="flex gap-4 text-sm text-muted-foreground">
    <span>{data.rowCount} rows</span>
    <span>{data.executionTime}ms</span>
  </div>

  <!-- Table -->
  <div class="border rounded overflow-auto max-h-[500px]">
    <Table>
      <TableHeader>
        <TableRow>
          {#each columns as column}
            <TableHead>
              <div>
                {column.name}
                <Badge variant="outline" class="ml-2">{column.dataType}</Badge>
              </div>
            </TableHead>
          {/each}
        </TableRow>
      </TableHeader>
      <TableBody>
        {#each rows as row}
          <TableRow>
            {#each columns as column}
              <TableCell>{row[column.name] ?? 'NULL'}</TableCell>
            {/each}
          </TableRow>
        {/each}
      </TableBody>
    </Table>
  </div>
</div>
```

**Tasks:**
- [ ] Create `Results` component
- [ ] Display column headers with types
- [ ] Display rows in table
- [ ] Show metadata (row count, execution time)
- [ ] Handle NULL values
- [ ] Add scrolling for large results
- [ ] Style table with shadcn

---

### 4.3 Error Handling

**File: `src/lib/components/ErrorDisplay.svelte`**

Display Postgres errors in a user-friendly way.

```svelte
<script lang="ts">
  import { Alert, AlertDescription, AlertTitle } from '$lib/components/ui/alert';
  import { AlertCircle } from 'lucide-svelte';

  export let error: string;

  // Parse Postgres error if possible
  // e.g., "ERROR:  syntax error at or near "SELEC""
  $: errorTitle = error.includes('ERROR:') ? 'SQL Error' : 'Error';
  $: errorMessage = error;
</script>

<Alert variant="destructive">
  <AlertCircle class="h-4 w-4" />
  <AlertTitle>{errorTitle}</AlertTitle>
  <AlertDescription class="font-mono text-sm">{errorMessage}</AlertDescription>
</Alert>
```

**Tasks:**
- [ ] Create error display component
- [ ] Parse Postgres error messages
- [ ] Show helpful error details
- [ ] Style with shadcn Alert

---

### 4.4 Query History (In-Memory)

**File: `src/lib/stores/history.ts`**

Store recent queries in memory (cleared on refresh).

```typescript
import { writable } from 'svelte/store';

export interface QueryHistoryItem {
  sql: string;
  timestamp: number;
  success: boolean;
}

export const queryHistory = writable<QueryHistoryItem[]>([]);

export function addToHistory(item: QueryHistoryItem) {
  queryHistory.update(history => {
    const updated = [item, ...history];
    return updated.slice(0, 50); // Keep last 50 queries
  });
}
```

**Add to UI (optional for MVP):**
- Sidebar or dropdown showing recent queries
- Click to load query into editor

**Tasks:**
- [ ] Create history store
- [ ] Add query to history on execute
- [ ] Display recent queries (optional UI for MVP)

---

## Phase 5: Testing & Polish (2 days)

### 5.1 Web App Testing

**Unit Tests:**
```bash
npm install -D @testing-library/svelte vitest jsdom
```

**Files to test:**
- `src/lib/services/websocket.test.ts` - WebSocket client
- `src/lib/services/introspection.test.ts` - Schema parsing
- `src/lib/components/Editor.test.ts` - Editor component
- `src/lib/components/Results.test.ts` - Results rendering

**Run tests:**
```bash
npm test
npm run test:coverage
```

**Target:** 80% coverage

**Tasks:**
- [ ] Write unit tests for services
- [ ] Write component tests
- [ ] Ensure 80%+ coverage
- [ ] Fix any failing tests

---

### 5.2 Go Proxy Testing

**Unit tests:**
- Already covered in Phase 1.7

**Integration tests:**
- Test proxy → real Postgres (use Docker for test database)

**Load tests (optional):**
- Test with many concurrent queries

**Tasks:**
- [ ] Run Go tests: `go test ./... -v`
- [ ] Integration test with Docker Postgres
- [ ] Verify coverage: `go test ./... -cover`

---

### 5.3 End-to-End Testing

**Manual E2E test flow:**
1. Build proxy binary: `cd proxy && make build-all`
2. Start test Postgres: `docker run -d -p 5432:5432 -e POSTGRES_PASSWORD=test postgres`
3. Run proxy: `./bin/postgres-proxy-linux-amd64 "postgres://postgres:test@localhost:5432/postgres"`
4. Copy URL with secret
5. Build web app: `cd web && npm run build`
6. Serve web app: `npm run preview`
7. Open proxy URL in browser
8. Test:
   - Connection established
   - Schema introspection works
   - Query execution works
   - Results display correctly
   - Autocomplete works
   - Error handling works

**Tasks:**
- [ ] Perform full E2E test
- [ ] Document any issues
- [ ] Fix critical bugs
- [ ] Verify on multiple browsers (Chrome, Firefox, Safari)

---

### 5.4 Code Quality

**Linting:**
```bash
# Web app
cd web
npm run lint
npm run format

# Go proxy
cd proxy
golangci-lint run
go fmt ./...
```

**Pre-commit hooks (optional):**
```bash
npm install -D husky lint-staged
npx husky install
```

**Tasks:**
- [ ] Run linters on all code
- [ ] Fix all linting errors
- [ ] Format all code
- [ ] Setup pre-commit hooks (optional)

---

### 5.5 Documentation

**Files to create:**
1. `README.md` (root) - Project overview
2. `web/README.md` - Web app development guide
3. `proxy/README.md` - Proxy development guide
4. `docs/installation.md` - User installation guide
5. `docs/architecture.md` - Technical architecture
6. `docs/development.md` - Developer setup guide

**Content for user-facing docs:**
- Installation instructions
- Usage examples
- Troubleshooting
- Supported Postgres versions
- Security considerations

**Tasks:**
- [ ] Write README files
- [ ] Write user documentation
- [ ] Write developer documentation
- [ ] Add screenshots/GIFs
- [ ] Proofread all docs

---

### 5.6 Deployment Preparation

**Web app deployment:**
- Build static files: `npm run build`
- Deploy to:
  - Vercel: `vercel deploy`
  - Netlify: `netlify deploy`
  - GitHub Pages: Push `build/` folder
  - Or any static host

**Proxy binary distribution:**
- Create GitHub release
- Upload binaries for all platforms
- Include SHA256 checksums
- Add release notes

**Tasks:**
- [ ] Deploy web app to static host
- [ ] Create GitHub release for proxy binaries
- [ ] Test download links
- [ ] Verify binaries work on each platform

---

## Phase 6: Launch Checklist

### Pre-Launch
- [ ] All tests passing (80%+ coverage)
- [ ] Zero linting errors
- [ ] Documentation complete
- [ ] Web app deployed and accessible
- [ ] Proxy binaries built and released
- [ ] Tested on Windows, macOS, Linux
- [ ] Tested on Chrome, Firefox, Safari

### Launch
- [ ] Announce on social media / forums
- [ ] Submit to relevant directories (ProductHunt, HackerNews, etc.)
- [ ] Monitor for user feedback and bug reports

### Post-Launch
- [ ] Collect user feedback
- [ ] Fix critical bugs
- [ ] Plan v2 features based on feedback

---

## Open Questions

1. **Microsoft autocomplete package** - You mentioned wanting to use "the Microsoft package that does autocomplete help on writing Postgres sql". Are you referring to:
   - Monaco Editor's built-in SQL support? (already included)
   - Or a specific package like `sql-language-server` or Azure Data Studio's extension?

   Let me know and I can integrate it!

2. **Proxy port configuration** - Should users be able to configure the proxy port (default 8080), or is hardcoded fine for MVP?

3. **SSL/TLS for Postgres** - The proxy will support SSL connections to Postgres. Should this be auto-detected or should users specify SSL mode?

4. **Query timeout** - Default query timeout? (30 seconds reasonable?)

5. **Binary distribution** - Where should binaries be hosted? GitHub Releases, or a custom download server?

---

## Estimated Timeline

| Phase | Duration | Tasks |
|-------|----------|-------|
| Phase 1: Go Proxy | 3 days | Connection, WebSocket server, Postgres client, build system |
| Phase 2: Web App Foundation | 2 days | SvelteKit, shadcn, WebSocket client, connection flow |
| Phase 3: SQL Editor | 3 days | Monaco, autocomplete, schema introspection |
| Phase 4: Query & Results | 2 days | Execute queries, display results, error handling |
| Phase 5: Testing & Polish | 2 days | Tests, linting, docs, deployment |
| **Total** | **12 days** | |

---

## Next Steps

1. **Answer open questions** above
2. **Choose deployment platforms**:
   - Web app: Vercel? Netlify? GitHub Pages?
   - Binaries: GitHub Releases?
3. **Start Phase 1**: Initialize repo and begin Go proxy development

Let me know if you have any questions or want to adjust the plan!
